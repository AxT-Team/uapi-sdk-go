/*
UAPI

UAPI å®˜æ–¹æ¥å£æ–‡æ¡£

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// MiscAPIService MiscAPI service
type MiscAPIService service

type ApiGetHistoryProgrammerRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	month *int32
	day *int32
}

// æœˆä»½ï¼Œ1-12ä¹‹é—´çš„æ•´æ•°ã€‚
func (r ApiGetHistoryProgrammerRequest) Month(month int32) ApiGetHistoryProgrammerRequest {
	r.month = &month
	return r
}

// æ—¥æœŸï¼Œ1-31ä¹‹é—´çš„æ•´æ•°ã€‚
func (r ApiGetHistoryProgrammerRequest) Day(day int32) ApiGetHistoryProgrammerRequest {
	r.day = &day
	return r
}

func (r ApiGetHistoryProgrammerRequest) Execute() (*GetHistoryProgrammer200Response, *http.Response, error) {
	return r.ApiService.GetHistoryProgrammerExecute(r)
}

/*
GetHistoryProgrammer è·å–æŒ‡å®šæ—¥æœŸçš„ç¨‹åºå‘˜å†å²äº‹ä»¶

æƒ³æŸ¥çœ‹ç¨‹åºå‘˜å†å²ä¸ŠæŸä¸ªç‰¹å®šæ—¥æœŸå‘ç”Ÿçš„å¤§äº‹ä»¶ï¼ŸæŒ‡å®šæœˆä»½å’Œæ—¥æœŸï¼Œæˆ‘ä»¬å°±èƒ½å‘Šè¯‰ä½ ï¼

## åŠŸèƒ½æ¦‚è¿°
é€šè¿‡æŒ‡å®šæœˆä»½å’Œæ—¥æœŸï¼Œè·å–è¯¥æ—¥å‘ç”Ÿçš„ç¨‹åºå‘˜ç›¸å…³å†å²äº‹ä»¶ã€‚åŒæ ·ä½¿ç”¨AIæ™ºèƒ½ç­›é€‰ï¼Œç¡®ä¿äº‹ä»¶çš„ç›¸å…³æ€§å’Œé‡è¦æ€§ã€‚

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHistoryProgrammerRequest
*/
func (a *MiscAPIService) GetHistoryProgrammer(ctx context.Context) ApiGetHistoryProgrammerRequest {
	return ApiGetHistoryProgrammerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetHistoryProgrammer200Response
func (a *MiscAPIService) GetHistoryProgrammerExecute(r ApiGetHistoryProgrammerRequest) (*GetHistoryProgrammer200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetHistoryProgrammer200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetHistoryProgrammer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/programmer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.month == nil {
		return localVarReturnValue, nil, reportError("month is required and must be specified")
	}
	if *r.month < 1 {
		return localVarReturnValue, nil, reportError("month must be greater than 1")
	}
	if *r.month > 12 {
		return localVarReturnValue, nil, reportError("month must be less than 12")
	}
	if r.day == nil {
		return localVarReturnValue, nil, reportError("day is required and must be specified")
	}
	if *r.day < 1 {
		return localVarReturnValue, nil, reportError("day must be greater than 1")
	}
	if *r.day > 31 {
		return localVarReturnValue, nil, reportError("day must be less than 31")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "month", r.month, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "day", r.day, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetHistoryProgrammer400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetHistoryProgrammerToday500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHistoryProgrammerTodayRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
}

func (r ApiGetHistoryProgrammerTodayRequest) Execute() (*GetHistoryProgrammerToday200Response, *http.Response, error) {
	return r.ApiService.GetHistoryProgrammerTodayExecute(r)
}

/*
GetHistoryProgrammerToday è·å–ä»Šå¤©çš„ç¨‹åºå‘˜å†å²äº‹ä»¶

æƒ³çŸ¥é“ç¨‹åºå‘˜å†å²ä¸Šçš„ä»Šå¤©å‘ç”Ÿäº†ä»€ä¹ˆå¤§äº‹å—ï¼Ÿè¿™ä¸ªæ¥å£å‘Šè¯‰ä½ ç­”æ¡ˆï¼

## åŠŸèƒ½æ¦‚è¿°
æˆ‘ä»¬ä½¿ç”¨AIæ™ºèƒ½ç­›é€‰ä»æµ·é‡å†å²äº‹ä»¶ä¸­æŒ‘é€‰å‡ºä¸ç¨‹åºå‘˜ã€è®¡ç®—æœºç§‘å­¦ç›¸å…³çš„é‡è¦äº‹ä»¶ã€‚æ¯ä¸ªäº‹ä»¶éƒ½ç»è¿‡é‡è¦æ€§è¯„åˆ†å’Œç›¸å…³æ€§è¯„åˆ†ï¼Œç¡®ä¿å†…å®¹è´¨é‡ã€‚

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHistoryProgrammerTodayRequest
*/
func (a *MiscAPIService) GetHistoryProgrammerToday(ctx context.Context) ApiGetHistoryProgrammerTodayRequest {
	return ApiGetHistoryProgrammerTodayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetHistoryProgrammerToday200Response
func (a *MiscAPIService) GetHistoryProgrammerTodayExecute(r ApiGetHistoryProgrammerTodayRequest) (*GetHistoryProgrammerToday200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetHistoryProgrammerToday200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetHistoryProgrammerToday")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/history/programmer/today"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetHistoryProgrammerToday500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscHotboardRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	type_ *string
}

// ä½ æƒ³è¦æŸ¥è¯¢çš„çƒ­æ¦œå¹³å°ã€‚æ”¯æŒå¤šç§ä¸»æµå¹³å°ç±»å‹ï¼Œè¯¦è§ä¸‹æ–¹[å¯é€‰å€¼](#å¯é€‰å€¼)è¡¨æ ¼ã€‚
func (r ApiGetMiscHotboardRequest) Type_(type_ string) ApiGetMiscHotboardRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetMiscHotboardRequest) Execute() (*GetMiscHotboard200Response, *http.Response, error) {
	return r.ApiService.GetMiscHotboardExecute(r)
}

/*
GetMiscHotboard è·å–å¤šå¹³å°å®æ—¶çƒ­æ¦œ

æƒ³å¿«é€Ÿè·Ÿä¸Šç½‘ç»œçƒ­ç‚¹ï¼Ÿè¿™ä¸ªæ¥å£è®©ä½ ä¸€ç½‘æ‰“å°½å„å¤§ä¸»æµå¹³å°çš„å®æ—¶çƒ­æ¦œ/çƒ­æœï¼

## åŠŸèƒ½æ¦‚è¿°
ä½ åªéœ€è¦æŒ‡å®šä¸€ä¸ªå¹³å°ç±»å‹ï¼Œå°±èƒ½è·å–åˆ°è¯¥å¹³å°å½“å‰çš„çƒ­æ¦œæ•°æ®åˆ—è¡¨ã€‚æ¯ä¸ªçƒ­æ¦œæ¡ç›®éƒ½åŒ…å«æ ‡é¢˜ã€çƒ­åº¦å€¼å’ŒåŸå§‹é“¾æ¥ã€‚éå¸¸é€‚åˆç”¨äºåˆ¶ä½œä¿¡æ¯èšåˆç±»åº”ç”¨æˆ–çœ‹æ¿ã€‚

## å¯é€‰å€¼
`type` å‚æ•°æ¥å—å¤šç§ä¸åŒçš„å€¼ï¼Œæ¯ç§å€¼å¯¹åº”ä¸€ä¸ªä¸åŒçš„çƒ­æ¦œæ¥æºã€‚ä»¥ä¸‹æ˜¯ç›®å‰æ”¯æŒçš„æ‰€æœ‰å€¼ï¼š

| åˆ†ç±»       | æ”¯æŒçš„ type å€¼ |
|------------|-----------------------------------------------------------------------------------------------------------------------------------|
| è§†é¢‘/ç¤¾åŒº  | bilibiliï¼ˆå“”å“©å“”å“©å¼¹å¹•ç½‘ï¼‰, acfunï¼ˆAç«™å¼¹å¹•è§†é¢‘ç½‘ç«™ï¼‰, weiboï¼ˆæ–°æµªå¾®åšçƒ­æœï¼‰, zhihuï¼ˆçŸ¥ä¹çƒ­æ¦œï¼‰, zhihu-dailyï¼ˆçŸ¥ä¹æ—¥æŠ¥çƒ­æ¦œï¼‰, douyinï¼ˆæŠ–éŸ³çƒ­æ¦œï¼‰, kuaishouï¼ˆå¿«æ‰‹çƒ­æ¦œï¼‰, douban-movieï¼ˆè±†ç“£ç”µå½±æ¦œå•ï¼‰, douban-groupï¼ˆè±†ç“£å°ç»„è¯é¢˜ï¼‰, tiebaï¼ˆç™¾åº¦è´´å§çƒ­å¸–ï¼‰, hupuï¼ˆè™æ‰‘çƒ­å¸–ï¼‰, miyousheï¼ˆç±³æ¸¸ç¤¾è¯é¢˜æ¦œï¼‰, ngabbsï¼ˆNGAæ¸¸æˆè®ºå›çƒ­å¸–ï¼‰, v2exï¼ˆV2EXæŠ€æœ¯ç¤¾åŒºçƒ­å¸–ï¼‰, 52pojieï¼ˆå¾çˆ±ç ´è§£çƒ­å¸–ï¼‰, hostlocï¼ˆå…¨çƒä¸»æœºäº¤æµè®ºå›ï¼‰, coolapkï¼ˆé…·å®‰çƒ­æ¦œï¼‰ |
| æ–°é—»/èµ„è®¯  | baiduï¼ˆç™¾åº¦çƒ­æœï¼‰, thepaperï¼ˆæ¾æ¹ƒæ–°é—»çƒ­æ¦œï¼‰, toutiaoï¼ˆä»Šæ—¥å¤´æ¡çƒ­æ¦œï¼‰, qq-newsï¼ˆè…¾è®¯æ–°é—»çƒ­æ¦œï¼‰, sinaï¼ˆæ–°æµªçƒ­æœï¼‰, sina-newsï¼ˆæ–°æµªæ–°é—»çƒ­æ¦œï¼‰, netease-newsï¼ˆç½‘æ˜“æ–°é—»çƒ­æ¦œï¼‰, huxiuï¼ˆè™å—…ç½‘çƒ­æ¦œï¼‰, ifanrï¼ˆçˆ±èŒƒå„¿çƒ­æ¦œï¼‰ |
| æŠ€æœ¯/IT    | sspaiï¼ˆå°‘æ•°æ´¾çƒ­æ¦œï¼‰, ithomeï¼ˆITä¹‹å®¶çƒ­æ¦œï¼‰, ithome-xijiayiï¼ˆITä¹‹å®¶Â·å–œåŠ ä¸€æ ç›®ï¼‰, juejinï¼ˆæ˜é‡‘ç¤¾åŒºçƒ­æ¦œï¼‰, jianshuï¼ˆç®€ä¹¦çƒ­æ¦œï¼‰, guokrï¼ˆæœå£³çƒ­æ¦œï¼‰, 36krï¼ˆ36æ°ªçƒ­æ¦œï¼‰, 51ctoï¼ˆ51CTOçƒ­æ¦œï¼‰, csdnï¼ˆCSDNåšå®¢çƒ­æ¦œï¼‰, nodeseekï¼ˆNodeSeek æŠ€æœ¯ç¤¾åŒºï¼‰, hellogithubï¼ˆHelloGitHub é¡¹ç›®æ¨èï¼‰ |
| æ¸¸æˆ       | lolï¼ˆè‹±é›„è”ç›Ÿçƒ­å¸–ï¼‰, genshinï¼ˆåŸç¥çƒ­æ¦œï¼‰, honkaiï¼ˆå´©å3çƒ­æ¦œï¼‰, starrailï¼ˆæ˜Ÿç©¹é“é“çƒ­æ¦œï¼‰ |
| å…¶ä»–       | wereadï¼ˆå¾®ä¿¡è¯»ä¹¦çƒ­é—¨ä¹¦ç±ï¼‰, weatheralarmï¼ˆå¤©æ°”é¢„è­¦ä¿¡æ¯ï¼‰, earthquakeï¼ˆåœ°éœ‡é€ŸæŠ¥ï¼‰, historyï¼ˆå†å²ä¸Šçš„ä»Šå¤©ï¼‰ |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscHotboardRequest
*/
func (a *MiscAPIService) GetMiscHotboard(ctx context.Context) ApiGetMiscHotboardRequest {
	return ApiGetMiscHotboardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscHotboard200Response
func (a *MiscAPIService) GetMiscHotboardExecute(r ApiGetMiscHotboardRequest) (*GetMiscHotboard200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscHotboard200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscHotboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/hotboard"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetMiscHotboard400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetMiscHotboard500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v GetMiscHotboard502Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscPhoneinfoRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	phone *string
}

// éœ€è¦æŸ¥è¯¢çš„11ä½ä¸­å›½å¤§é™†æ‰‹æœºå·ç ã€‚
func (r ApiGetMiscPhoneinfoRequest) Phone(phone string) ApiGetMiscPhoneinfoRequest {
	r.phone = &phone
	return r
}

func (r ApiGetMiscPhoneinfoRequest) Execute() (*GetMiscPhoneinfo200Response, *http.Response, error) {
	return r.ApiService.GetMiscPhoneinfoExecute(r)
}

/*
GetMiscPhoneinfo æŸ¥è¯¢æ‰‹æœºå·ç å½’å±åœ°ä¿¡æ¯

æƒ³çŸ¥é“ä¸€ä¸ªæ‰‹æœºå·ç æ¥è‡ªå“ªé‡Œï¼Ÿæ˜¯ç§»åŠ¨ã€è”é€šè¿˜æ˜¯ç”µä¿¡ï¼Ÿè¿™ä¸ªæ¥å£å¯ä»¥å‘Šè¯‰ä½ ç­”æ¡ˆã€‚

## åŠŸèƒ½æ¦‚è¿°
æä¾›ä¸€ä¸ªå›½å†…çš„æ‰‹æœºå·ç ï¼Œæˆ‘ä»¬ä¼šæŸ¥è¯¢å¹¶è¿”å›å®ƒçš„å½’å±åœ°ï¼ˆçœä»½å’ŒåŸå¸‚ï¼‰ä»¥åŠæ‰€å±çš„è¿è¥å•†ä¿¡æ¯ã€‚

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscPhoneinfoRequest
*/
func (a *MiscAPIService) GetMiscPhoneinfo(ctx context.Context) ApiGetMiscPhoneinfoRequest {
	return ApiGetMiscPhoneinfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscPhoneinfo200Response
func (a *MiscAPIService) GetMiscPhoneinfoExecute(r ApiGetMiscPhoneinfoRequest) (*GetMiscPhoneinfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscPhoneinfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscPhoneinfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/phoneinfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.phone == nil {
		return localVarReturnValue, nil, reportError("phone is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetMiscPhoneinfo400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetMiscPhoneinfo500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscRandomnumberRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	min *int32
	max *int32
	count *int32
	allowRepeat *bool
	allowDecimal *bool
	decimalPlaces *int32
}

// ç”Ÿæˆéšæœºæ•°çš„æœ€å°å€¼ï¼ˆåŒ…å«ï¼‰ã€‚
func (r ApiGetMiscRandomnumberRequest) Min(min int32) ApiGetMiscRandomnumberRequest {
	r.min = &min
	return r
}

// ç”Ÿæˆéšæœºæ•°çš„æœ€å¤§å€¼ï¼ˆåŒ…å«ï¼‰ã€‚
func (r ApiGetMiscRandomnumberRequest) Max(max int32) ApiGetMiscRandomnumberRequest {
	r.max = &max
	return r
}

// éœ€è¦ç”Ÿæˆçš„éšæœºæ•°çš„æ•°é‡ã€‚
func (r ApiGetMiscRandomnumberRequest) Count(count int32) ApiGetMiscRandomnumberRequest {
	r.count = &count
	return r
}

// æ˜¯å¦å…è®¸ç”Ÿæˆçš„å¤šä¸ªæ•°å­—ä¸­å‡ºç°é‡å¤å€¼ã€‚
func (r ApiGetMiscRandomnumberRequest) AllowRepeat(allowRepeat bool) ApiGetMiscRandomnumberRequest {
	r.allowRepeat = &allowRepeat
	return r
}

// æ˜¯å¦ç”Ÿæˆå°ï¼ˆæµ®ç‚¹ï¼‰æ•°ã€‚å¦‚æœä¸º falseï¼Œåˆ™åªç”Ÿæˆæ•´æ•°ã€‚
func (r ApiGetMiscRandomnumberRequest) AllowDecimal(allowDecimal bool) ApiGetMiscRandomnumberRequest {
	r.allowDecimal = &allowDecimal
	return r
}

// å¦‚æœ &#x60;allow_decimal&#x3D;true&#x60;ï¼Œè¿™é‡Œå¯ä»¥æŒ‡å®šå°æ•°çš„ä½æ•°ã€‚
func (r ApiGetMiscRandomnumberRequest) DecimalPlaces(decimalPlaces int32) ApiGetMiscRandomnumberRequest {
	r.decimalPlaces = &decimalPlaces
	return r
}

func (r ApiGetMiscRandomnumberRequest) Execute() (*GetMiscRandomnumber200Response, *http.Response, error) {
	return r.ApiService.GetMiscRandomnumberExecute(r)
}

/*
GetMiscRandomnumber ç”Ÿæˆé«˜åº¦å¯å®šåˆ¶çš„éšæœºæ•°

éœ€è¦ä¸€ä¸ªç®€å•çš„éšæœºæ•°ï¼Œè¿˜æ˜¯éœ€è¦ä¸€ä¸²ä¸é‡å¤çš„ã€å¸¦å°æ•°çš„éšæœºæ•°ï¼Ÿè¿™ä¸ªæ¥å£éƒ½èƒ½æ»¡è¶³ä½ ï¼

## åŠŸèƒ½æ¦‚è¿°
è¿™æ˜¯ä¸€ä¸ªå¼ºå¤§çš„éšæœºæ•°ç”Ÿæˆå™¨ã€‚ä½ å¯ä»¥æŒ‡å®šç”Ÿæˆçš„èŒƒå›´ï¼ˆæœ€å¤§/æœ€å°å€¼ï¼‰ã€æ•°é‡ã€æ˜¯å¦å…è®¸é‡å¤ã€ä»¥åŠæ˜¯å¦ç”Ÿæˆå°æ•°ï¼ˆå¹¶æŒ‡å®šå°æ•°ä½æ•°ï¼‰ã€‚

## æµç¨‹å›¾
```mermaid
graph TD
    A[å¼€å§‹] --> B{å‚æ•°æ ¡éªŒ};
    B --> |é€šè¿‡| C{æ˜¯å¦å…è®¸å°æ•°?};
    C --> |æ˜¯| D[ç”Ÿæˆéšæœºå°æ•°];
    C --> |å¦| E[ç”Ÿæˆéšæœºæ•´æ•°];
    D --> F{æ˜¯å¦å…è®¸é‡å¤?};
    E --> F;
    F --> |æ˜¯| G[ç›´æ¥ç”ŸæˆæŒ‡å®šæ•°é‡];
    F --> |å¦| H[ç”Ÿæˆä¸é‡å¤çš„æ•°å­—];
    G --> I[è¿”å›ç»“æœ];
    H --> I;
    B --> |å¤±è´¥| J[è¿”å› 400 é”™è¯¯];
```
## ä½¿ç”¨é¡»çŸ¥
> [!WARNING]
> **ä¸é‡å¤ç”Ÿæˆçš„é€»è¾‘é™åˆ¶**
> å½“è®¾ç½® `allow_repeat=false` æ—¶ï¼Œè¯·ç¡®ä¿å–å€¼èŒƒå›´ `(max - min + 1)` å¤§äºæˆ–ç­‰äºä½ è¯·æ±‚çš„æ•°é‡ `count`ã€‚å¦åˆ™ï¼Œç³»ç»Ÿå°†æ— æ³•ç”Ÿæˆè¶³å¤Ÿçš„ä¸é‡å¤æ•°å­—ï¼Œè¯·æ±‚ä¼šå¤±è´¥å¹¶è¿”å› 400 é”™è¯¯ã€‚

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscRandomnumberRequest
*/
func (a *MiscAPIService) GetMiscRandomnumber(ctx context.Context) ApiGetMiscRandomnumberRequest {
	return ApiGetMiscRandomnumberRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscRandomnumber200Response
func (a *MiscAPIService) GetMiscRandomnumberExecute(r ApiGetMiscRandomnumberRequest) (*GetMiscRandomnumber200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscRandomnumber200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscRandomnumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/randomnumber"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.min != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min", r.min, "form", "")
	} else {
        var defaultValue int32 = 1
        parameterAddToHeaderOrQuery(localVarQueryParams, "min", defaultValue, "form", "")
        r.min = &defaultValue
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	} else {
        var defaultValue int32 = 100
        parameterAddToHeaderOrQuery(localVarQueryParams, "max", defaultValue, "form", "")
        r.max = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
        var defaultValue int32 = 1
        parameterAddToHeaderOrQuery(localVarQueryParams, "count", defaultValue, "form", "")
        r.count = &defaultValue
	}
	if r.allowRepeat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_repeat", r.allowRepeat, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "allow_repeat", defaultValue, "form", "")
        r.allowRepeat = &defaultValue
	}
	if r.allowDecimal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_decimal", r.allowDecimal, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "allow_decimal", defaultValue, "form", "")
        r.allowDecimal = &defaultValue
	}
	if r.decimalPlaces != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "decimal_places", r.decimalPlaces, "form", "")
	} else {
        var defaultValue int32 = 2
        parameterAddToHeaderOrQuery(localVarQueryParams, "decimal_places", defaultValue, "form", "")
        r.decimalPlaces = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetMiscRandomnumber400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscTimestampRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	ts *string
}

// éœ€è¦è½¬æ¢çš„Unixæ—¶é—´æˆ³ï¼Œæ”¯æŒ10ä½ï¼ˆç§’ï¼‰æˆ–13ä½ï¼ˆæ¯«ç§’ï¼‰ã€‚
func (r ApiGetMiscTimestampRequest) Ts(ts string) ApiGetMiscTimestampRequest {
	r.ts = &ts
	return r
}

func (r ApiGetMiscTimestampRequest) Execute() (*GetMiscTimestamp200Response, *http.Response, error) {
	return r.ApiService.GetMiscTimestampExecute(r)
}

/*
GetMiscTimestamp è½¬æ¢æ—¶é—´æˆ³ (æ—§ç‰ˆï¼Œæ¨èä½¿ç”¨/convert/unixtime)

è¿™æ˜¯ä¸€ä¸ªç”¨äºå°†Unixæ—¶é—´æˆ³è½¬æ¢ä¸ºäººç±»å¯è¯»æ—¥æœŸæ—¶é—´çš„æ—§ç‰ˆæ¥å£ã€‚

## åŠŸèƒ½æ¦‚è¿°
è¾“å…¥ä¸€ä¸ªç§’çº§æˆ–æ¯«ç§’çº§çš„æ—¶é—´æˆ³ï¼Œè¿”å›å…¶å¯¹åº”çš„æœ¬åœ°æ—¶é—´å’ŒUTCæ—¶é—´ã€‚

> [!WARNING]
> **æ¥å£å·²è¿‡æ—¶**ï¼šè¿™ä¸ªæ¥å£å·²è¢«æ–°çš„ `/convert/unixtime` å–ä»£ã€‚æ–°æ¥å£åŠŸèƒ½æ›´å¼ºå¤§ï¼Œæ”¯æŒåŒå‘è½¬æ¢ã€‚æˆ‘ä»¬å»ºè®®ä½ è¿ç§»åˆ°æ–°æ¥å£ã€‚

[ğŸ‘‰ å‰å¾€æ–°ç‰ˆæ¥å£æ–‡æ¡£](/docs/api-reference/get-convert-unixtime)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscTimestampRequest
*/
func (a *MiscAPIService) GetMiscTimestamp(ctx context.Context) ApiGetMiscTimestampRequest {
	return ApiGetMiscTimestampRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscTimestamp200Response
func (a *MiscAPIService) GetMiscTimestampExecute(r ApiGetMiscTimestampRequest) (*GetMiscTimestamp200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscTimestamp200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscTimestamp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/timestamp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ts == nil {
		return localVarReturnValue, nil, reportError("ts is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ts", r.ts, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetMiscTimestamp400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscTrackingCarriersRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
}

func (r ApiGetMiscTrackingCarriersRequest) Execute() (*GetMiscTrackingCarriers200Response, *http.Response, error) {
	return r.ApiService.GetMiscTrackingCarriersExecute(r)
}

/*
GetMiscTrackingCarriers è·å–æ”¯æŒçš„å¿«é€’å…¬å¸åˆ—è¡¨

ä¸ç¡®å®šç³»ç»Ÿæ”¯æŒå“ªäº›å¿«é€’å…¬å¸ï¼Ÿè¿™ä¸ªæ¥å£è¿”å›å®Œæ•´çš„æ”¯æŒåˆ—è¡¨ã€‚

> [!VIP]
> æœ¬APIç›®å‰å¤„äº**é™æ—¶å…è´¹**é˜¶æ®µï¼Œæˆ‘ä»¬é¼“åŠ±å¼€å‘è€…é›†æˆå’Œæµ‹è¯•ã€‚æœªæ¥ï¼Œå®ƒå°†è½¬ä¸ºä»˜è´¹APIï¼Œä¸ºç”¨æˆ·æä¾›æ›´ç¨³å®šå’Œå¼ºå¤§çš„æœåŠ¡ã€‚

## åŠŸèƒ½æ¦‚è¿°
è·å–ç³»ç»Ÿå½“å‰æ”¯æŒçš„æ‰€æœ‰å¿«é€’å…¬å¸åˆ—è¡¨ï¼ŒåŒ…æ‹¬æ¯å®¶å…¬å¸çš„æ ‡å‡†ç¼–ç ï¼ˆcodeï¼‰å’Œä¸­æ–‡åç§°ï¼ˆnameï¼‰ã€‚

## ä½¿ç”¨å»ºè®®
- **æ¨èç¼“å­˜**ï¼šè¿™ä¸ªåˆ—è¡¨åŸºæœ¬ä¸ä¼šé¢‘ç¹å˜åŠ¨ï¼Œå»ºè®®åœ¨åº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨ä¸€æ¬¡å¹¶ç¼“å­˜åˆ°æœ¬åœ°
- **åº”ç”¨åœºæ™¯**ï¼šé€‚åˆç”¨äºæ„å»ºå¿«é€’å…¬å¸é€‰æ‹©å™¨ã€ä¸‹æ‹‰èœå•ç­‰UIç»„ä»¶
- **ç¼“å­˜æ—¶é•¿**ï¼šå»ºè®®ç¼“å­˜24å°æ—¶æˆ–æ›´ä¹…

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscTrackingCarriersRequest
*/
func (a *MiscAPIService) GetMiscTrackingCarriers(ctx context.Context) ApiGetMiscTrackingCarriersRequest {
	return ApiGetMiscTrackingCarriersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscTrackingCarriers200Response
func (a *MiscAPIService) GetMiscTrackingCarriersExecute(r ApiGetMiscTrackingCarriersRequest) (*GetMiscTrackingCarriers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscTrackingCarriers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscTrackingCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/tracking/carriers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscTrackingDetectRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	trackingNumber *string
}

// éœ€è¦è¯†åˆ«çš„å¿«é€’å•å·ã€‚
func (r ApiGetMiscTrackingDetectRequest) TrackingNumber(trackingNumber string) ApiGetMiscTrackingDetectRequest {
	r.trackingNumber = &trackingNumber
	return r
}

func (r ApiGetMiscTrackingDetectRequest) Execute() (*GetMiscTrackingDetect200Response, *http.Response, error) {
	return r.ApiService.GetMiscTrackingDetectExecute(r)
}

/*
GetMiscTrackingDetect è¯†åˆ«å¿«é€’å…¬å¸

ä¸ç¡®å®šæ‰‹é‡Œçš„å¿«é€’å•å·å±äºå“ªå®¶å¿«é€’å…¬å¸ï¼Ÿè¿™ä¸ªæ¥å£ä¸“é—¨åšè¯†åˆ«ï¼Œä¸æŸ¥ç‰©æµã€‚

> [!VIP]
> æœ¬APIç›®å‰å¤„äº**é™æ—¶å…è´¹**é˜¶æ®µï¼Œæˆ‘ä»¬é¼“åŠ±å¼€å‘è€…é›†æˆå’Œæµ‹è¯•ã€‚æœªæ¥ï¼Œå®ƒå°†è½¬ä¸ºä»˜è´¹APIï¼Œä¸ºç”¨æˆ·æä¾›æ›´ç¨³å®šå’Œå¼ºå¤§çš„æœåŠ¡ã€‚

## åŠŸèƒ½æ¦‚è¿°
è¾“å…¥å¿«é€’å•å·ï¼Œç³»ç»Ÿä¼šæ ¹æ®å•å·è§„åˆ™å¿«é€Ÿè¯†åˆ«å‡ºæœ€å¯èƒ½çš„å¿«é€’å…¬å¸ã€‚å¦‚æœå­˜åœ¨å¤šä¸ªå¯èƒ½çš„åŒ¹é…ç»“æœï¼Œè¿˜ä¼šåœ¨ `alternatives` å­—æ®µä¸­è¿”å›å¤‡é€‰é¡¹ï¼Œä¾›ä½ å‚è€ƒé€‰æ‹©ã€‚

## ä½¿ç”¨é¡»çŸ¥
- **è¯†åˆ«é€Ÿåº¦å¿«**ï¼šåªåšè§„åˆ™åŒ¹é…ï¼Œä¸æŸ¥è¯¢ç‰©æµä¿¡æ¯ï¼Œå“åº”é€Ÿåº¦é€šå¸¸åœ¨100mså†…
- **å‡†ç¡®ç‡é«˜**ï¼šåŸºäºå„å¿«é€’å…¬å¸çš„å•å·è§„åˆ™è¿›è¡Œæ™ºèƒ½è¯†åˆ«ï¼Œå‡†ç¡®ç‡è¶…è¿‡95%
- **å¤‡é€‰æ–¹æ¡ˆ**ï¼šå½“å•å·è§„åˆ™å¯èƒ½åŒ¹é…å¤šå®¶å¿«é€’å…¬å¸æ—¶ï¼Œä¼šæä¾›æ‰€æœ‰å¯èƒ½çš„é€‰é¡¹

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscTrackingDetectRequest
*/
func (a *MiscAPIService) GetMiscTrackingDetect(ctx context.Context) ApiGetMiscTrackingDetectRequest {
	return ApiGetMiscTrackingDetectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscTrackingDetect200Response
func (a *MiscAPIService) GetMiscTrackingDetectExecute(r ApiGetMiscTrackingDetectRequest) (*GetMiscTrackingDetect200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscTrackingDetect200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscTrackingDetect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/tracking/detect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.trackingNumber == nil {
		return localVarReturnValue, nil, reportError("trackingNumber is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tracking_number", r.trackingNumber, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetMiscTrackingDetect404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscTrackingQueryRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	trackingNumber *string
	carrierCode *string
}

// å¿«é€’å•å·ï¼Œé€šå¸¸æ˜¯ä¸€ä¸²10-20ä½çš„æ•°å­—æˆ–å­—æ¯æ•°å­—ç»„åˆã€‚
func (r ApiGetMiscTrackingQueryRequest) TrackingNumber(trackingNumber string) ApiGetMiscTrackingQueryRequest {
	r.trackingNumber = &trackingNumber
	return r
}

// å¿«é€’å…¬å¸ç¼–ç ï¼ˆå¯é€‰ï¼‰ã€‚ä¸å¡«å†™æ—¶ç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«ï¼Œå¡«å†™åå¯åŠ å¿«æŸ¥è¯¢é€Ÿåº¦ã€‚
func (r ApiGetMiscTrackingQueryRequest) CarrierCode(carrierCode string) ApiGetMiscTrackingQueryRequest {
	r.carrierCode = &carrierCode
	return r
}

func (r ApiGetMiscTrackingQueryRequest) Execute() (*GetMiscTrackingQuery200Response, *http.Response, error) {
	return r.ApiService.GetMiscTrackingQueryExecute(r)
}

/*
GetMiscTrackingQuery æŸ¥è¯¢å¿«é€’ç‰©æµä¿¡æ¯

ä¹°äº†ä¸œè¥¿æƒ³çŸ¥é“å¿«é€’åˆ°å“ªå„¿äº†ï¼Ÿè¿™ä¸ªæ¥å£å¸®ä½ å®æ—¶è¿½è¸ªç‰©æµçŠ¶æ€ã€‚

> [!VIP]
> æœ¬APIç›®å‰å¤„äº**é™æ—¶å…è´¹**é˜¶æ®µï¼Œæˆ‘ä»¬é¼“åŠ±å¼€å‘è€…é›†æˆå’Œæµ‹è¯•ã€‚æœªæ¥ï¼Œå®ƒå°†è½¬ä¸ºä»˜è´¹APIï¼Œä¸ºç”¨æˆ·æä¾›æ›´ç¨³å®šå’Œå¼ºå¤§çš„æœåŠ¡ã€‚

## åŠŸèƒ½æ¦‚è¿°
æä¾›ä¸€ä¸ªå¿«é€’å•å·ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«å¿«é€’å…¬å¸å¹¶è¿”å›å®Œæ•´çš„ç‰©æµè½¨è¿¹ä¿¡æ¯ã€‚æ”¯æŒä¸­é€šã€åœ†é€šã€éŸµè¾¾ã€ç”³é€šã€æå…”ã€é¡ºä¸°ã€äº¬ä¸œã€EMSã€å¾·é‚¦ç­‰60+å›½å†…å¤–ä¸»æµå¿«é€’å…¬å¸ã€‚

## ä½¿ç”¨é¡»çŸ¥
- **è‡ªåŠ¨è¯†åˆ«**ï¼šä¸çŸ¥é“æ˜¯å“ªå®¶å¿«é€’ï¼Ÿç³»ç»Ÿä¼šæ ¹æ®å•å·è§„åˆ™è‡ªåŠ¨è¯†åˆ«å¿«é€’å…¬å¸ï¼ˆæ¨èä½¿ç”¨ï¼‰
- **æ‰‹åŠ¨æŒ‡å®š**ï¼šå¦‚æœå·²çŸ¥å¿«é€’å…¬å¸ï¼Œå¯ä»¥ä¼ é€’ `carrier_code` å‚æ•°ï¼ŒæŸ¥è¯¢é€Ÿåº¦ä¼šæ›´å¿«
- **æŸ¥è¯¢æ—¶æ•ˆ**ï¼šç‰©æµä¿¡æ¯å®æ—¶æŸ¥è¯¢ï¼Œå“åº”æ—¶é—´é€šå¸¸åœ¨1-2ç§’å†…

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscTrackingQueryRequest
*/
func (a *MiscAPIService) GetMiscTrackingQuery(ctx context.Context) ApiGetMiscTrackingQueryRequest {
	return ApiGetMiscTrackingQueryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscTrackingQuery200Response
func (a *MiscAPIService) GetMiscTrackingQueryExecute(r ApiGetMiscTrackingQueryRequest) (*GetMiscTrackingQuery200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscTrackingQuery200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscTrackingQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/tracking/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.trackingNumber == nil {
		return localVarReturnValue, nil, reportError("trackingNumber is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tracking_number", r.trackingNumber, "form", "")
	if r.carrierCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier_code", r.carrierCode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetMiscTrackingQuery400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetMiscTrackingQuery404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscWeatherRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	city *string
	adcode *string
}

// æ ‡å‡†çš„åŸå¸‚åç§°ï¼Œå¦‚ &#39;åŒ—äº¬&#39;, &#39;ä¸Šæµ·å¸‚&#39;, &#39;ç¦ç”°åŒº&#39;ã€‚è¯·ä½¿ç”¨å®˜æ–¹çš„çœã€å¸‚ã€åŒºå¿è¡Œæ”¿åŒºåˆ’åç§°ã€‚
func (r ApiGetMiscWeatherRequest) City(city string) ApiGetMiscWeatherRequest {
	r.city = &city
	return r
}

// é«˜å¾·åœ°å›¾çš„6ä½æ•°å­—åŸå¸‚ç¼–ç ã€‚ä¾‹å¦‚ï¼ŒåŒ—äº¬å¸‚çš„Adcodeæ˜¯ &#39;110000&#39;ã€‚ä½¿ç”¨AdcodeæŸ¥è¯¢æ›´å‡†ç¡®ã€æ›´å¿«é€Ÿã€‚
func (r ApiGetMiscWeatherRequest) Adcode(adcode string) ApiGetMiscWeatherRequest {
	r.adcode = &adcode
	return r
}

func (r ApiGetMiscWeatherRequest) Execute() (*GetMiscWeather200Response, *http.Response, error) {
	return r.ApiService.GetMiscWeatherExecute(r)
}

/*
GetMiscWeather æŸ¥è¯¢å®æ—¶å¤©æ°”ä¿¡æ¯

å‡ºé—¨å‰ï¼ŒæŸ¥ä¸€ä¸‹å¤©æ°”æ€»æ˜¯ä¸ªå¥½ä¹ æƒ¯ã€‚è¿™ä¸ªæ¥å£ä¸ºä½ æä¾›ç²¾å‡†ã€å®æ—¶çš„å¤©æ°”æ•°æ®ã€‚

## åŠŸèƒ½æ¦‚è¿°
ä½ å¯ä»¥é€šè¿‡åŸå¸‚åç§°æˆ–é«˜å¾·åœ°å›¾çš„Adcodeæ¥æŸ¥è¯¢æŒ‡å®šåœ°åŒºçš„å®æ—¶å¤©æ°”çŠ¶å†µï¼ŒåŒ…æ‹¬å¤©æ°”ç°è±¡ã€æ¸©åº¦ã€æ¹¿åº¦ã€é£å‘å’Œé£åŠ›ç­‰ã€‚

## ä½¿ç”¨é¡»çŸ¥
- **å‚æ•°ä¼˜å…ˆçº§**ï¼šå½“ä½ åŒæ—¶æä¾›äº† `city` (åŸå¸‚å) å’Œ `adcode` (åŸå¸‚ç¼–ç ) ä¸¤ä¸ªå‚æ•°æ—¶ï¼Œç³»ç»Ÿä¼š **ä¼˜å…ˆä½¿ç”¨ `adcode`** è¿›è¡ŒæŸ¥è¯¢ï¼Œå› ä¸ºå®ƒæ›´ç²¾ç¡®ã€‚
- **æŸ¥è¯¢èŒƒå›´**ï¼šä¸ºäº†ä¿è¯æŸ¥è¯¢çš„å‡†ç¡®æ€§ï¼Œæˆ‘ä»¬çš„æœåŠ¡ä»…æ”¯æŒæ ‡å‡†çš„â€œçœâ€ã€â€œå¸‚â€ã€â€œåŒº/å¿â€çº§åˆ«çš„è¡Œæ”¿åŒºåˆ’åç§°æŸ¥è¯¢ï¼Œä¸ä¿è¯èƒ½æŸ¥è¯¢åˆ°ä¹¡é•‡æˆ–å…·ä½“åœ°ç‚¹ã€‚

## é”™è¯¯å¤„ç†æŒ‡å—
- **410 Gone**: è¿™ä¸ªç‰¹æ®Šçš„é”™è¯¯ç æ„å‘³ç€ä½ æŸ¥è¯¢çš„åœ°åŒºæ— æ•ˆæˆ–ä¸å—æˆ‘ä»¬æ”¯æŒã€‚æ¯”å¦‚ä½ è¾“å…¥äº†â€œç«æ˜Ÿâ€ï¼Œæˆ–è€…æŸä¸ªæˆ‘ä»¬æ— æ³•è¯†åˆ«çš„æ‘åº„åç§°ã€‚è¿™ä¸ªçŠ¶æ€ç å‘Šè¯‰ä½ ï¼Œè¿™ä¸ªâ€œèµ„æºâ€æ˜¯æ°¸ä¹…æ€§åœ°ä¸å¯ç”¨äº†ã€‚

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscWeatherRequest
*/
func (a *MiscAPIService) GetMiscWeather(ctx context.Context) ApiGetMiscWeatherRequest {
	return ApiGetMiscWeatherRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscWeather200Response
func (a *MiscAPIService) GetMiscWeatherExecute(r ApiGetMiscWeatherRequest) (*GetMiscWeather200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscWeather200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscWeather")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/weather"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	}
	if r.adcode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adcode", r.adcode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetMiscWeather400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 410 {
			var v GetMiscWeather410Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetMiscWeather500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v GetMiscWeather502Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMiscWorldtimeRequest struct {
	ctx context.Context
	ApiService *MiscAPIService
	city *string
}

// ä½ éœ€è¦æŸ¥è¯¢çš„åŸå¸‚æˆ–åœ°åŒºï¼Œè¯·ä½¿ç”¨æ ‡å‡†çš„ IANA æ—¶åŒºæ•°æ®åº“åç§°ï¼Œä¾‹å¦‚ &#39;Shanghai&#39;, &#39;Asia/Tokyo&#39;, &#39;America/New_York&#39;ã€‚
func (r ApiGetMiscWorldtimeRequest) City(city string) ApiGetMiscWorldtimeRequest {
	r.city = &city
	return r
}

func (r ApiGetMiscWorldtimeRequest) Execute() (*GetMiscWorldtime200Response, *http.Response, error) {
	return r.ApiService.GetMiscWorldtimeExecute(r)
}

/*
GetMiscWorldtime æŸ¥è¯¢å…¨çƒä»»æ„æ—¶åŒºçš„æ—¶é—´

éœ€è¦å’Œå›½å¤–çš„æœ‹å‹å¼€ä¼šï¼Œæƒ³çŸ¥é“ä»–é‚£è¾¹ç°åœ¨å‡ ç‚¹ï¼Ÿç”¨è¿™ä¸ªæ¥å£ä¸€æŸ¥ä¾¿çŸ¥ã€‚

## åŠŸèƒ½æ¦‚è¿°
æ ¹æ®æ ‡å‡†çš„æ—¶åŒºåç§°ï¼ˆä¾‹å¦‚ 'Asia/Shanghai' æˆ– 'Europe/London'ï¼‰ï¼Œè·å–è¯¥æ—¶åŒºçš„å½“å‰å‡†ç¡®æ—¶é—´ã€UTCåç§»é‡ã€æ˜ŸæœŸç­‰ä¿¡æ¯ã€‚

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMiscWorldtimeRequest
*/
func (a *MiscAPIService) GetMiscWorldtime(ctx context.Context) ApiGetMiscWorldtimeRequest {
	return ApiGetMiscWorldtimeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMiscWorldtime200Response
func (a *MiscAPIService) GetMiscWorldtimeExecute(r ApiGetMiscWorldtimeRequest) (*GetMiscWorldtime200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMiscWorldtime200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiscAPIService.GetMiscWorldtime")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/misc/worldtime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.city == nil {
		return localVarReturnValue, nil, reportError("city is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetMiscWorldtime400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetMiscWorldtime404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
