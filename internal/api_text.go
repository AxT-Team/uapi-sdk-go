/*
UAPI

UAPI 官方接口文档

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package uapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TextAPIService TextAPI service
type TextAPIService service

type ApiGetTextMd5Request struct {
	ctx context.Context
	ApiService *TextAPIService
	text *string
}

// 需要计算哈希值的文本
func (r ApiGetTextMd5Request) Text(text string) ApiGetTextMd5Request {
	r.text = &text
	return r
}

func (r ApiGetTextMd5Request) Execute() (*GetTextMd5200Response, *http.Response, error) {
	return r.ApiService.GetTextMd5Execute(r)
}

/*
GetTextMd5 计算文本的MD5哈希值(GET)

一个快速计算文本 MD5 哈希值的工具，适用于短文本且不关心参数暴露的场景。

## 功能概述
通过GET请求的查询参数传入文本，返回其32位小写的MD5哈希值。

> [!NOTE]
> 对于较长或敏感的文本，我们推荐使用本接口的 POST 版本，以避免URL长度限制和参数暴露问题。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTextMd5Request
*/
func (a *TextAPIService) GetTextMd5(ctx context.Context) ApiGetTextMd5Request {
	return ApiGetTextMd5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTextMd5200Response
func (a *TextAPIService) GetTextMd5Execute(r ApiGetTextMd5Request) (*GetTextMd5200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTextMd5200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.GetTextMd5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/md5"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetTextMd5400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTextAesDecryptRequest struct {
	ctx context.Context
	ApiService *TextAPIService
	postTextAesDecryptRequest *PostTextAesDecryptRequest
}

// 包含待解密文本 &#39;text&#39;、密钥 &#39;key&#39; 和随机数 &#39;nonce&#39; 的JSON对象
func (r ApiPostTextAesDecryptRequest) PostTextAesDecryptRequest(postTextAesDecryptRequest PostTextAesDecryptRequest) ApiPostTextAesDecryptRequest {
	r.postTextAesDecryptRequest = &postTextAesDecryptRequest
	return r
}

func (r ApiPostTextAesDecryptRequest) Execute() (*PostTextAesDecrypt200Response, *http.Response, error) {
	return r.ApiService.PostTextAesDecryptExecute(r)
}

/*
PostTextAesDecrypt 使用AES算法解密文本

收到了用AES加密的密文？把它、密钥和随机数（nonce）交给我们，就能还原出原始内容。

## 功能概述
这是一个标准的AES解密接口。你需要提供经过Base64编码的密文、加密时使用的密钥和nonce（随机数，通常为16字节字符串）。

> [!IMPORTANT]
> **关于密钥 `key`**
> 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。
> 
> **关于随机数 `nonce`**
> 通常为16字节字符串，需与加密时一致。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTextAesDecryptRequest
*/
func (a *TextAPIService) PostTextAesDecrypt(ctx context.Context) ApiPostTextAesDecryptRequest {
	return ApiPostTextAesDecryptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostTextAesDecrypt200Response
func (a *TextAPIService) PostTextAesDecryptExecute(r ApiPostTextAesDecryptRequest) (*PostTextAesDecrypt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTextAesDecrypt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.PostTextAesDecrypt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/aes/decrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTextAesDecryptRequest == nil {
		return localVarReturnValue, nil, reportError("postTextAesDecryptRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTextAesDecryptRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostTextAesDecrypt400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v PostTextAesDecrypt500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTextAesEncryptRequest struct {
	ctx context.Context
	ApiService *TextAPIService
	postTextAesEncryptRequest *PostTextAesEncryptRequest
}

// 包含待加密文本 &#39;text&#39; 和密钥 &#39;key&#39; 的JSON对象
func (r ApiPostTextAesEncryptRequest) PostTextAesEncryptRequest(postTextAesEncryptRequest PostTextAesEncryptRequest) ApiPostTextAesEncryptRequest {
	r.postTextAesEncryptRequest = &postTextAesEncryptRequest
	return r
}

func (r ApiPostTextAesEncryptRequest) Execute() (*PostTextAesEncrypt200Response, *http.Response, error) {
	return r.ApiService.PostTextAesEncryptExecute(r)
}

/*
PostTextAesEncrypt 使用AES算法加密文本

需要安全地传输或存储一些文本信息？AES加密是一个可靠的选择。

## 功能概述
这是一个标准的AES加密接口。你提供需要加密的明文和密钥，我们返回经过Base64编码的密文。

> [!IMPORTANT]
> **关于密钥 `key`**
> 我们支持 AES-128, AES-192, 和 AES-256。请确保你提供的密钥 `key` 的长度（字节数）正好是 **16**、**24** 或 **32**，以分别对应这三种加密强度。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTextAesEncryptRequest
*/
func (a *TextAPIService) PostTextAesEncrypt(ctx context.Context) ApiPostTextAesEncryptRequest {
	return ApiPostTextAesEncryptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostTextAesEncrypt200Response
func (a *TextAPIService) PostTextAesEncryptExecute(r ApiPostTextAesEncryptRequest) (*PostTextAesEncrypt200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTextAesEncrypt200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.PostTextAesEncrypt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/aes/encrypt"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTextAesEncryptRequest == nil {
		return localVarReturnValue, nil, reportError("postTextAesEncryptRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTextAesEncryptRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostTextAesEncrypt400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v PostTextAesEncrypt500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTextAnalyzeRequest struct {
	ctx context.Context
	ApiService *TextAPIService
	postTextAnalyzeRequest *PostTextAnalyzeRequest
}

// 包含待分析文本 &#39;text&#39; 的JSON对象
func (r ApiPostTextAnalyzeRequest) PostTextAnalyzeRequest(postTextAnalyzeRequest PostTextAnalyzeRequest) ApiPostTextAnalyzeRequest {
	r.postTextAnalyzeRequest = &postTextAnalyzeRequest
	return r
}

func (r ApiPostTextAnalyzeRequest) Execute() (*PostTextAnalyze200Response, *http.Response, error) {
	return r.ApiService.PostTextAnalyzeExecute(r)
}

/*
PostTextAnalyze 多维度分析文本内容

想知道一篇文章有多少字、多少个词、或者多少行？这个接口可以帮你快速统计。

## 功能概述
你提供一段文本，我们会从多个维度进行分析，并返回其字符数、词数、句子数、段落数和行数。这对于文本编辑、内容管理等场景非常有用。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTextAnalyzeRequest
*/
func (a *TextAPIService) PostTextAnalyze(ctx context.Context) ApiPostTextAnalyzeRequest {
	return ApiPostTextAnalyzeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostTextAnalyze200Response
func (a *TextAPIService) PostTextAnalyzeExecute(r ApiPostTextAnalyzeRequest) (*PostTextAnalyze200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTextAnalyze200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.PostTextAnalyze")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTextAnalyzeRequest == nil {
		return localVarReturnValue, nil, reportError("postTextAnalyzeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTextAnalyzeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostTextAnalyze400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTextBase64DecodeRequest struct {
	ctx context.Context
	ApiService *TextAPIService
	postTextBase64DecodeRequest *PostTextBase64DecodeRequest
}

// 包含待解码文本 &#39;text&#39; 的JSON对象
func (r ApiPostTextBase64DecodeRequest) PostTextBase64DecodeRequest(postTextBase64DecodeRequest PostTextBase64DecodeRequest) ApiPostTextBase64DecodeRequest {
	r.postTextBase64DecodeRequest = &postTextBase64DecodeRequest
	return r
}

func (r ApiPostTextBase64DecodeRequest) Execute() (*PostTextBase64Decode200Response, *http.Response, error) {
	return r.ApiService.PostTextBase64DecodeExecute(r)
}

/*
PostTextBase64Decode 解码Base64编码的文本

这是一个简单实用的 Base64 解码工具。

## 功能概述
你提供一个 Base64 编码的字符串，我们帮你解码成原始的 UTF-8 文本。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTextBase64DecodeRequest
*/
func (a *TextAPIService) PostTextBase64Decode(ctx context.Context) ApiPostTextBase64DecodeRequest {
	return ApiPostTextBase64DecodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostTextBase64Decode200Response
func (a *TextAPIService) PostTextBase64DecodeExecute(r ApiPostTextBase64DecodeRequest) (*PostTextBase64Decode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTextBase64Decode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.PostTextBase64Decode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/base64/decode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTextBase64DecodeRequest == nil {
		return localVarReturnValue, nil, reportError("postTextBase64DecodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTextBase64DecodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostTextBase64Decode400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTextBase64EncodeRequest struct {
	ctx context.Context
	ApiService *TextAPIService
	postTextBase64EncodeRequest *PostTextBase64EncodeRequest
}

// 包含待编码文本 &#39;text&#39; 的JSON对象
func (r ApiPostTextBase64EncodeRequest) PostTextBase64EncodeRequest(postTextBase64EncodeRequest PostTextBase64EncodeRequest) ApiPostTextBase64EncodeRequest {
	r.postTextBase64EncodeRequest = &postTextBase64EncodeRequest
	return r
}

func (r ApiPostTextBase64EncodeRequest) Execute() (*PostTextBase64Encode200Response, *http.Response, error) {
	return r.ApiService.PostTextBase64EncodeExecute(r)
}

/*
PostTextBase64Encode 将文本进行Base64编码

这是一个简单实用的 Base64 编码工具。

## 功能概述
你提供一段原始文本，我们帮你转换成 Base64 编码的字符串。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTextBase64EncodeRequest
*/
func (a *TextAPIService) PostTextBase64Encode(ctx context.Context) ApiPostTextBase64EncodeRequest {
	return ApiPostTextBase64EncodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostTextBase64Encode200Response
func (a *TextAPIService) PostTextBase64EncodeExecute(r ApiPostTextBase64EncodeRequest) (*PostTextBase64Encode200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTextBase64Encode200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.PostTextBase64Encode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/base64/encode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTextBase64EncodeRequest == nil {
		return localVarReturnValue, nil, reportError("postTextBase64EncodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTextBase64EncodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostTextBase64Encode400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTextMd5Request struct {
	ctx context.Context
	ApiService *TextAPIService
	postTextMd5Request *PostTextMd5Request
}

func (r ApiPostTextMd5Request) PostTextMd5Request(postTextMd5Request PostTextMd5Request) ApiPostTextMd5Request {
	r.postTextMd5Request = &postTextMd5Request
	return r
}

func (r ApiPostTextMd5Request) Execute() (*GetTextMd5200Response, *http.Response, error) {
	return r.ApiService.PostTextMd5Execute(r)
}

/*
PostTextMd5 计算文本的MD5哈希值 (POST)

一个用于计算文本 MD5 哈希值的标准工具，推荐使用此版本。

## 功能概述
通过POST请求的表单体传入文本，返回其32位小写的MD5哈希值。相比GET版本，此方法更适合处理较长或包含敏感信息的文本。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTextMd5Request
*/
func (a *TextAPIService) PostTextMd5(ctx context.Context) ApiPostTextMd5Request {
	return ApiPostTextMd5Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTextMd5200Response
func (a *TextAPIService) PostTextMd5Execute(r ApiPostTextMd5Request) (*GetTextMd5200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTextMd5200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.PostTextMd5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/md5"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTextMd5Request == nil {
		return localVarReturnValue, nil, reportError("postTextMd5Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTextMd5Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostTextMd5400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTextMd5VerifyRequest struct {
	ctx context.Context
	ApiService *TextAPIService
	postTextMd5VerifyRequest *PostTextMd5VerifyRequest
}

// 包含待校验文本 &#39;text&#39; 和哈希值 &#39;hash&#39; 的JSON对象
func (r ApiPostTextMd5VerifyRequest) PostTextMd5VerifyRequest(postTextMd5VerifyRequest PostTextMd5VerifyRequest) ApiPostTextMd5VerifyRequest {
	r.postTextMd5VerifyRequest = &postTextMd5VerifyRequest
	return r
}

func (r ApiPostTextMd5VerifyRequest) Execute() (*PostTextMd5Verify200Response, *http.Response, error) {
	return r.ApiService.PostTextMd5VerifyExecute(r)
}

/*
PostTextMd5Verify 校验MD5哈希值

下载了一个文件，想确认它在传输过程中有没有损坏？校验MD5值是最常用的方法。

## 功能概述
你提供原始文本和一个MD5哈希值，我们帮你计算文本的哈希，并与你提供的哈希进行比对，告诉你它们是否匹配。这在文件完整性校验等场景下非常有用。

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTextMd5VerifyRequest
*/
func (a *TextAPIService) PostTextMd5Verify(ctx context.Context) ApiPostTextMd5VerifyRequest {
	return ApiPostTextMd5VerifyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PostTextMd5Verify200Response
func (a *TextAPIService) PostTextMd5VerifyExecute(r ApiPostTextMd5VerifyRequest) (*PostTextMd5Verify200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTextMd5Verify200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TextAPIService.PostTextMd5Verify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/md5/verify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTextMd5VerifyRequest == nil {
		return localVarReturnValue, nil, reportError("postTextMd5VerifyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTextMd5VerifyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PostTextMd5Verify400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
